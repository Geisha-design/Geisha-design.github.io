{"title":"算法之基础","slug":"算法之基础","date":"2020-04-18T08:21:21.000Z","updated":"2020-04-19T08:21:21.000Z","comments":true,"path":"api/articles/算法之基础.json","photos":[],"link":"","excerpt":"算法基础，了解算法的基础知识，算法的种类，知道什么是好算法。","covers":null,"content":"<p>算法基础，了解算法的基础知识，算法的种类，知道什么是好算法。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"算法特性\"><a href=\"#算法特性\" class=\"headerlink\" title=\"算法特性\"></a>算法特性</h1><ul>\n<li><strong>输入</strong>：可以有零个或多个参数</li>\n<li><strong>输出</strong>：必须有一个或多个结果</li>\n<li><strong>有穷性</strong>：算法必须会结束，没有无限循环</li>\n<li><strong>确定性</strong>：有唯一结果</li>\n<li><strong>可行性</strong>：算法每一步都能通过执行有限次数完成</li>\n</ul>\n<h1 id=\"算法设计要求\"><a href=\"#算法设计要求\" class=\"headerlink\" title=\"算法设计要求\"></a>算法设计要求</h1><ul>\n<li><strong>正确性</strong>：算法至少具有输入、输出和过程明确的加工处理，正确反映问题的需求，最后得到期望的答案<ul>\n<li>算法程序没有语法错误</li>\n<li>算法程序对于合法输入能产生期望的答案</li>\n<li>算法程序对于非法输入能产生警告和提示</li>\n<li>算法程序对于故意掉难得测试输入都能产生期望的结果</li>\n</ul>\n</li>\n<li><strong>可读性</strong>：算法便于阅读、理解和交流</li>\n<li><strong>健壮性</strong>：能够处理异常、崩溃或莫名其妙的结果</li>\n<li><strong>高时间效率和低存储量</strong>：算法要考虑处理速度和内存用量</li>\n</ul>\n<h1 id=\"算法效率度量方法\"><a href=\"#算法效率度量方法\" class=\"headerlink\" title=\"算法效率度量方法\"></a>算法效率度量方法</h1><ul>\n<li>事后统计方法：通过执行多个输入测试，记录执行时间平均值</li>\n<li>事前估算方法：通过统计方法对算法进行估算，涉及以下因素<ol>\n<li>算法策略，<strong>例子使用公式或者循环等</strong></li>\n<li>编译后的代码质量，<strong>基础操作的次数统计</strong></li>\n<li>问题的输入规模，<strong>例子数值大小或元素数量等</strong></li>\n<li>机器执行指令的速度，<strong>硬件性能</strong></li>\n</ol>\n</li>\n</ul>\n<p><strong>算法基础种类分别有：<code>1</code>、<code>n</code>、<code>n*n</code>。</strong></p>\n<p>一般使用公式或瀑布式条件判断的算法策略属于<code>1</code>；使用单个循环的属于<code>n</code>；使用嵌套循环的属于<code>n*n</code>。3种算法中往往常数算法<code>1</code>要优于<code>n</code>和<code>n*n</code>。给以下基础操作次数公式分类：</p>\n<ul>\n<li><code>1</code>：<code>3</code>、<code>5</code>、<code>9</code>等</li>\n<li><code>n</code>：<code>n</code>、<code>n+1</code>、<code>2n+3</code>等</li>\n<li><code>n*n</code>：<code>n^2</code>、<code>n^2+5</code>、<code>2n^3+1</code>等</li>\n</ul>\n<p><strong>一般判断算法好坏，更应该关注函数公式的主项：指数最高项。</strong><br>比如算法<code>2n^2+n+3</code>对比算法<code>n^3+2n+1</code>，因为<code>2n^2</code>指数低于<code>n^3</code>，所以算法<code>2n^2+n+3</code>优于算法<code>n^3+2n+1</code>。</p>\n<h2 id=\"怎么分析一个算法的输入时间？\"><a href=\"#怎么分析一个算法的输入时间？\" class=\"headerlink\" title=\"怎么分析一个算法的输入时间？\"></a>怎么分析一个算法的输入时间？</h2><ul>\n<li>抽象算法：去除算法中循环的外包装、条件的判断、变量的声明、打印输出等操作</li>\n<li>指令计数：统计关联的输入模式下基础操作的数量</li>\n</ul>\n<h2 id=\"求和1-100的算法例子分析\"><a href=\"#求和1-100的算法例子分析\" class=\"headerlink\" title=\"求和1-100的算法例子分析\"></a>求和1-100的算法例子分析</h2><p>以下<em>算法一</em>，算法策略使用<code>循环</code>，编译后的代码质量为<code>n</code>次，问题的输入规模<code>100</code>，机器执行指令的速度取决于算法运行所在计算机。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><figcaption><span>JavaScript 算法一</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, i = <span class=\"number\">1</span>, n = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (; i &lt;= n; i++) &#123;</span><br><span class=\"line\">  sum += i;                  <span class=\"comment\">// 执行 n 次</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>以下<em>算法二</em>，算法策略使用<code>公式</code>，编译后的代码质量为<code>1</code>次，问题的输入规模<code>100</code>，机器执行指令的速度取决于算法运行所在计算机。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><figcaption><span>JavaScript 算法二</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, i = <span class=\"number\">1</span>, n = <span class=\"number\">100</span>;</span><br><span class=\"line\">sum = (i + n) * n  / <span class=\"number\">2</span>;      <span class=\"comment\">// 执行 1 次</span></span><br></pre></td></tr></table></figure></div>\n\n<p>对比以上算法，它们的输入规模都是<code>100</code>，在同一计算机运行的情况下，<strong>算法一</strong>的基础操作次数受输入规模的影响，造成工作量超出<strong>算法二</strong>，<strong>所以算法二效率更高</strong>。</p>\n<h2 id=\"求和3x3表格内数值的例子分析\"><a href=\"#求和3x3表格内数值的例子分析\" class=\"headerlink\" title=\"求和3x3表格内数值的例子分析\"></a>求和3x3表格内数值的例子分析</h2><p>以下<em>表格遍历例子</em>，算法策略使用<code>嵌套的循环</code>，编译后的代码质量为<code>n^2</code>次，问题的输入规模<code>3x3</code>，机器执行指令的速度取决于算法运行所在计算机。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><figcaption><span>JavaScript 表格遍历求和例子</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>, </span><br><span class=\"line\">    table = [</span><br><span class=\"line\">      [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">      [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">    ];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= table.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= table[i].length; j++) &#123;</span><br><span class=\"line\">    sum += table[i][j];      <span class=\"comment\">// 执行 n^2 次</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>以上算法，它根据表格的大小，基础操作的数量是以指数上升的，<strong>所以<code>3x3</code>的表格内数值总和计算一共有基础操作<code>3^2</code>等于9次</strong>。</p>\n<h1 id=\"用大O记法表示算法时间复杂度\"><a href=\"#用大O记法表示算法时间复杂度\" class=\"headerlink\" title=\"用大O记法表示算法时间复杂度\"></a>用大O记法表示算法时间复杂度</h1><p>复杂度分为：<strong>时间复杂度</strong>或<strong>空间复杂度</strong><br><strong>一般计算“复杂度”是指“时间复杂度”，而不是空间复杂度，目前主流还是时间复杂度，不求用内存换取时间。</strong></p>\n<p>**T(n) = O(f(n))**，<code>f(n)</code>为算法的函数或入口，随着输入规模<code>n</code>的增长，<code>T(n)</code>增长最慢的算法为最优算法。因为以下原因：</p>\n<p><strong>基础操作数量 = 时间</strong></p>\n<p>所以当<code>n</code>翻倍时，<em>基础操作数量</em>增长越少，花费的<em>时间</em>越少。</p>\n<p>上面用到的三个求和算法例子，如果用大O表示算法的时间复杂度分别为<code>O(1)</code>、<code>O(n)</code>、<code>O(n^2)</code>。</p>\n<p><strong>大O记法表示时间的增长率</strong></p>\n<ul>\n<li><code>O(1)</code>：增长率不变</li>\n<li><code>O(n)</code>：增长率倍数增长</li>\n<li><code>O(n^2)</code>：增长率指数增长</li>\n</ul>\n<h2 id=\"推导大O阶方法\"><a href=\"#推导大O阶方法\" class=\"headerlink\" title=\"推导大O阶方法\"></a>推导大O阶方法</h2><p>用一下方法来推导<code>5</code>、<code>2n+3</code>、<code>n(n+1)/2</code>和<code>O(logn)</code>的大O阶：</p>\n<ol>\n<li>用常数1取代所有加法常数</li>\n<li>只保留最高阶项</li>\n<li>最高阶项不是1的话，去除这个项相乘的常数</li>\n</ol>\n<p><code>5</code> =&gt; <code>O(1)</code>，<br><code>2n+3</code> =&gt; <code>O(n)</code>，<br><code>n(n+1)/2</code> =&gt; <code>O(n^2)</code></p>\n<p>一面这个例子的话就是<code>O(logn)</code>：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><figcaption><span>JavaScript</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, n = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; n) &#123;</span><br><span class=\"line\">  i *= <span class=\"number\">2</span>; <span class=\"comment\">// 2^x = n，那么 x = log(2)n，x为循环次数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"常见的时间复杂度\"><a href=\"#常见的时间复杂度\" class=\"headerlink\" title=\"常见的时间复杂度\"></a>常见的时间复杂度</h2><table>\n<thead>\n<tr>\n<th align=\"center\">例子</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">术语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">5</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">常数阶</td>\n</tr>\n<tr>\n<td align=\"center\">3n+4</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">线性阶</td>\n</tr>\n<tr>\n<td align=\"center\">3n^2+4n+5</td>\n<td align=\"center\">O(n^2)</td>\n<td align=\"center\">平方阶</td>\n</tr>\n<tr>\n<td align=\"center\">3log(2)n+4</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">对数阶</td>\n</tr>\n<tr>\n<td align=\"center\">2n+3nlog(2)n+14</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">nlogn阶</td>\n</tr>\n<tr>\n<td align=\"center\">n^3+2n^2+4n+6</td>\n<td align=\"center\">O(n^3)</td>\n<td align=\"center\">立方阶</td>\n</tr>\n<tr>\n<td align=\"center\">2^n</td>\n<td align=\"center\">O(2^n)</td>\n<td align=\"center\">指数阶</td>\n</tr>\n</tbody></table>\n<p>时间复杂度对比：<br><strong><code>O(1)</code> &lt; <code>O(logn)</code> &lt; <code>O(n)</code> &lt; <code>O(nlogn)</code> &lt; <code>O(n^2)</code> &lt; <code>O(n^3)</code> &lt; <code>O(2^n)</code> &lt; <code>O(n!)</code> &lt; <code>O(n^n)</code></strong></p>\n<blockquote>\n<p>本文参考：<br><a href=\"https://www.bilibili.com/video/BV1jW411K7yg\">【C语言描述】《数据结构和算法》（小甲鱼）</a></p>\n</blockquote>\n","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":4,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"基础","slug":"基础","count":2,"path":"api/tags/基础.json"},{"name":"Big O","slug":"Big-O","count":1,"path":"api/tags/Big-O.json"}]}